<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.4">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-09T15:43:10+09:00</updated><id>http://localhost:4000/</id><title type="html">Rocky’s Research Blog</title><subtitle>This is a Research Blog of Rocky Lim</subtitle><entry><title type="html">How Computers Work [02]</title><link href="http://localhost:4000/book/hcw02/" rel="alternate" type="text/html" title="How Computers Work [02]" /><published>2017-08-04T22:44:20+09:00</published><updated>2017-08-04T22:44:20+09:00</updated><id>http://localhost:4000/book/hcw02</id><content type="html" xml:base="http://localhost:4000/book/hcw02/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw.jpg&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#하노이-타워&quot; id=&quot;markdown-toc-하노이-타워&quot;&gt;하노이 타워&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컴퓨터프로세서가-잘-할-수-있는-것&quot; id=&quot;markdown-toc-컴퓨터프로세서가-잘-할-수-있는-것&quot;&gt;컴퓨터(프로세서)가 잘 할 수 있는 것.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컴퓨터가-잘-할-수-없는-것&quot; id=&quot;markdown-toc-컴퓨터가-잘-할-수-없는-것&quot;&gt;컴퓨터가 잘 할 수 없는 것.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-a-processor-tracks-numbers&quot; id=&quot;markdown-toc-how-a-processor-tracks-numbers&quot;&gt;HOW A PROCESSOR TRACKS NUMBERS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cpu-central-processing-unit-중앙처리장치&quot; id=&quot;markdown-toc-cpu-central-processing-unit-중앙처리장치&quot;&gt;CPU; Central Processing Unit: 중앙처리장치&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;h2 id=&quot;하노이-타워&quot;&gt;하노이 타워&lt;/h2&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_05.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;하노이 타워 게임, 혹은 하노이 타워 퍼즐(문제)라고 불리는 게임 이 게임은 다음과 같은 2가지 규칙을 지키며 tower(pole)에 끼워져 있는 원반(disk)를 다른 pole로 옮기는 게임 혹은 문제를 말한다.&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_02.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;예를 들어 총 3개의 원반으로 하노이 타워가 구성되었을 때 한 타워에서 다른 타워로 모든 원반을 옮기는 과정은 다음과 같다.&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_03.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;총 4개의 원반으로 하노이 타워가 구성된다면 같이 3개의 원반으로 구성된 타워에서 다음과 같이 확장하여 문제를 해결 할 수 있다.&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_04.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;따라서 원반 개수가 하나 씩 늘어날 수록 원반을 옮기는 데 걸리는 시간(옮기는 원반의 개수)은 약 2배 씩 늘어나게 된다.&lt;/p&gt;

&lt;p&gt;하노이 타워의 유래인 인도 전설에 의하면, 인도 베나레스의 사원에 있는 64개의 원판을 가진 하노이 타워를 승려들이 차례로 한쪽 끝에서 다른쪽 끝으로 옮기게 되면 세상의 종말이 오게 된다고 한다. 원반의 개수가 증가하면서 옮겨야 하는 원반의 개수는 약 2배 씩 증가하기 때문에, 64개의 원반을 한쪽 끝에서 다른 한쪽 끝으로 옮기기 위해서는 18,446,744,073,709,551,615번의 이동이 필요하다. 승려들이 1초에 한 번 씩 원반을 옮긴다고 생각했을 때, 약 5,850 억 년이 걸릴 것이므로, 하노이 타워로 인해 지구가 종말 할 일은 걱정하지 않아도 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;컴퓨터프로세서가-잘-할-수-있는-것&quot;&gt;컴퓨터(프로세서)가 잘 할 수 있는 것.&lt;/h2&gt;
&lt;p&gt;“A processor such as the Intel Core i7-965 Extreme Edition, with a clock speed of 3.20 gigahertz—3,200,000,000 ticks of the clock every second—could complete the monks’ original tower exercise in 13 day and four hours.”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;단순한-연산-같은-작업연산의-반복과-같은-작업--하노이타워의-디스크-옮기기시뮬레이션&quot;&gt;단순한 연산, 같은 작업(연산)의 반복과 같은 작업 = &lt;strong&gt;하노이타워의 디스크 옮기기(시뮬레이션)&lt;/strong&gt;.&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;수학-연산&quot;&gt;수학 연산&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“Multiplying 100 by 3,000 is accomplishing by adding 3,000 a hundred times. Division consists of subtracting one number from another continuously until the result is 0 or the final number is not large enough to subtract the divisor from it.”&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 컴퓨터는 곱셈과 나눗셈 계산하기 위해 여러번 더하거나 빼는 것을 반복하는 방식으로 계산한다. 사람은 구구단을 “외워서” 계산하지만 결국 사람 역시 여러번 더하거나 빼는방식을 통해 공식이나 방법을 만들었음 -&amp;gt; 자연스러운 방식!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;wheres-waldowith-a-same-template&quot;&gt;Where’s Waldo(with a same template)&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
 &lt;img src=&quot;http://localhost:4000/images/hcw02_08.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
 &lt;img src=&quot;http://localhost:4000/images/hcw02_09.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 100px;&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;컴퓨터가-잘-할-수-없는-것&quot;&gt;컴퓨터가 잘 할 수 없는 것.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;그림그리기-소설-쓰기와-같은-감성적-활동매우-높은-난이도의-현실-세계를-모델링-해야-함&quot;&gt;그림그리기, 소설 쓰기와 같은 감성적 활동(매우 높은 난이도의 현실 세계를 모델링 해야 함)&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;컴퓨터는 통찰력과 직감이 없음.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구글, 인공지능(AI)이 쓴 연애소설: &lt;a href=&quot;http://cm.asiae.co.kr/view.htm?no=2016051608243121704#ba&quot;&gt;http://cm.asiae.co.kr/view.htm?no=2016051608243121704#ba&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;wheres-waldowith-a-different-template&quot;&gt;Where’s Waldo(with a different template)&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
 &lt;img src=&quot;http://localhost:4000/images/hcw02_07.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
 &lt;img src=&quot;http://localhost:4000/images/hcw02_09.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 100px;&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;how-a-processor-tracks-numbers&quot;&gt;HOW A PROCESSOR TRACKS NUMBERS&lt;/h2&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_06.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;컴퓨터가 bit들로 이루어진 2진수를 계산하는 방법은 우리가 사람이 메모를 하면서 숫자 계산을 하는 것과 유사하다.&lt;/p&gt;

&lt;p&gt;똑똑한 사람은 복잡한 수학 계산을 머릿속으로 계산 할 수 있지만, 매우 단순한 숫자 계산에서도 연필과 메모장이 있어야 숫자가 어디서 어디로 더해지거나 곱해지는 등의 결과를 만들어내는 중간 과정을 확인 해 볼 수 있다. 컴퓨터 프로세서가 계산을 위해 사용하는 메모장은 레지스터라고 하는 저장장치 이고, 연필은 전기(전가기파, 펄스)이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;마이크로 프로세서의 레지스터는 마이크로 프로세서 칩 내부의 더 빠른 메모리(메인메모리 보다 빠른 메모리, = 캐시 메모리 cache memory)에 위치한다.
이 레지스터에는 수학 명령어를 수행하는 프로세서의 산술 논리 장치 (ALU)와 프로세서를 통해 명령과 데이터를 집계하는 제어 장치가 레지스터에 빠르게 접근 할 수 있다. 레지스터의 크기는 프로세서가 한 번에 처리 할 수있는 데이터의 양을 결정한다. 대부분의 PC에는 32 비트 또는 64 비트의 데이터 레지스터가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The processor’s control unit directs the fetching and execution of program instructions. (See “How a Microprocessor Moves Data”, on pages 36-37.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It uses an electrical signal to &lt;strong&gt;fetch&lt;/strong&gt; each &lt;strong&gt;instruction&lt;/strong&gt;, &lt;strong&gt;decodes&lt;/strong&gt; it, and sends another control signal to the arithmetic logic unit telling the ALU what operation to carry out.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_10.jpeg&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;instruction - 모든 프그램은 수많은 instruction의 순차적 조합으로 이루어져 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_11.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw02_12.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
  &lt;img src=&quot;http://localhost:4000/images/hcw02_13.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;With each clock cycle—the thin unit of time during which the different components of a computer can do one thing—the processor writes or reads the values of the bits by sending or withholding a pulse of electricity to each. Each chunk of binary numbers is only that. They have no labels to identify them as instructions, data, values going into a computation, or the product of executing instructions. What the values represent depends on which registers the control unit uses to store them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Address registers collect the contents of different addresses in RAM or in the processor’s on-board cache, where they have been prefetched in anticipation that they would be needed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When the processor reads the contents of a location in memory, it tells the data bus to place those values into a memory data register. When the processor wants to write values to memory, it places the values in the memory data register, where the bus retrieves them to transfer to RAM.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A program counter register holds the memory address of the next value the processor will fetch. As soon as a value is retrieved, the processor increments the program counter’s contents by 1 so it points to the next program location. (A computer launches a program by putting the program’s first value into the counter register.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The processor puts the results of executing an operation into several accumulation registers, where they await the results of other executing operations, similar to those shown in the illustration on the next spread, “How a Processor Does Math.” Some of the instructions call for adding or subtracting the numbers in two accumulators to yield a third value that is stored in still another accumulator.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cpu-central-processing-unit-중앙처리장치&quot;&gt;CPU; Central Processing Unit: 중앙처리장치&lt;/h2&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">How a Little Microprocessor Does Big Things, How Motherboards Conduct a Symphony of Dataㅁ</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22hcw02_01.png%22%7D" /></entry><entry><title type="html">How Computers Work [01]</title><link href="http://localhost:4000/book/hcw01/" rel="alternate" type="text/html" title="How Computers Work [01]" /><published>2017-08-04T22:44:20+09:00</published><updated>2017-08-04T22:44:20+09:00</updated><id>http://localhost:4000/book/hcw01</id><content type="html" xml:base="http://localhost:4000/book/hcw01/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw.jpg&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#전자기파의-개념-및-종류&quot; id=&quot;markdown-toc-전자기파의-개념-및-종류&quot;&gt;전자기파의 개념 및 종류&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#어떻게-전자기파를-통해-정보가-전달될까&quot; id=&quot;markdown-toc-어떻게-전자기파를-통해-정보가-전달될까&quot;&gt;어떻게 전자기파를 통해 정보가 전달될까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#analog--digital&quot; id=&quot;markdown-toc-analog--digital&quot;&gt;analog &amp;amp; Digital&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#트렌지스터&quot; id=&quot;markdown-toc-트렌지스터&quot;&gt;트렌지스터&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#32bit-컴퓨터-64bit-컴퓨터&quot; id=&quot;markdown-toc-32bit-컴퓨터-64bit-컴퓨터&quot;&gt;32bit 컴퓨터? 64bit 컴퓨터?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#어떻게-정보가-ram메인메모리에-저장되는가&quot; id=&quot;markdown-toc-어떻게-정보가-ram메인메모리에-저장되는가&quot;&gt;어떻게 정보가 RAM(메인메모리)에 저장되는가?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#어떻게-정보가-flash-memory에-저장되는가&quot; id=&quot;markdown-toc-어떻게-정보가-flash-memory에-저장되는가&quot;&gt;&lt;strong&gt;어떻게 정보가 Flash Memory에 저장되는가?&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#메모리-구조&quot; id=&quot;markdown-toc-메모리-구조&quot;&gt;메모리 구조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;h2 id=&quot;전자기파의-개념-및-종류&quot;&gt;전자기파의 개념 및 종류&lt;/h2&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_01.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;라디오, 전자파, 적외선, 가시광선, 적외선, x-ray, gamma-ray&lt;/p&gt;

&lt;h2 id=&quot;어떻게-전자기파를-통해-정보가-전달될까&quot;&gt;어떻게 전자기파를 통해 정보가 전달될까?&lt;/h2&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_02.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;정보는 전자기파가 생성되는 빈도와 전자기파가 존재하는 시간을 통해 정보로서 전달된다.&lt;/p&gt;

&lt;h2 id=&quot;analog--digital&quot;&gt;analog &amp;amp; Digital&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;아날로그 온도계&lt;/strong&gt; - 온도계 내의 수은주 또는 알콜이 온도가 올라감에 따라 팽창&lt;br /&gt;
&lt;strong&gt;디지털 온도계&lt;/strong&gt; - 서미스터라고 불리는 전기 부품, 온도가 상승하면 서미스터의 전류 저항이 줄어든다. 전기량을 숫자로 적절하게 변환시켜주는 미니 프로세서를 통해 온도를 확인 할 수 있음.&lt;/p&gt;

&lt;h3 id=&quot;analog-to-digital-convertor-adc&quot;&gt;analog-to-digital convertor (ADC).&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_05.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;샘플링(sampling)이라고 도 함. Threshold를 기반으로 아날로그 신호를 디지털 신호로 변환&lt;/p&gt;

&lt;h3 id=&quot;single-bit-sampling&quot;&gt;single bit sampling&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_06.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;multi-bit-sampling&quot;&gt;multi bit sampling&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_08.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;현실세계에서 얻을 수 있는 정보를 single bit sampling을 한다면 정보의 손실이 너무 많기 때문에, 영상, 소리, 빛의 양 등 많은 아날로그 정보들은 multi bit sampling 을 통해 Digital화 된다.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_07.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;트렌지스터&quot;&gt;트렌지스터&lt;/h2&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_03.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;트렌지스터: 모든 마이크로 칩이 구축되는 기본 빌딩 블록.
전류가 트랜지스터를 통과하면 트랜지스터는 1을 나타내거나 전류가 통과하지 않으면 0이 된다.
이러한 트렌지스터의 조합을 통해 bit 조합을 나타낼 수 있고, 컴퓨터를 포함한 모든 전자기기에서 사용되는 정보의 단위를 구성할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;32bit-컴퓨터-64bit-컴퓨터&quot;&gt;32bit 컴퓨터? 64bit 컴퓨터?&lt;/h2&gt;
&lt;p&gt;프로세서가 한 번에 처리할 수 있는 bit의 수를 말한다. 시스템 메모리와도 관련이 있음. 얘를 들어 32bit컴퓨터는 최대 가르킬 수 있는 메모리 주소가 32bit로 제한될 것이다. 32bit = 4 * 2^30 = 4GB. 따라서 32bit 컴퓨터 에서는 4GB이상의 메모리 칩을 사용해도 성능 향상이 없음.&lt;/p&gt;

&lt;h2 id=&quot;어떻게-정보가-ram메인메모리에-저장되는가&quot;&gt;어떻게 정보가 RAM(메인메모리)에 저장되는가?&lt;/h2&gt;

&lt;p&gt;메인메모리(RAM)에 electric pulse(bit stream)가 들어온다면 RAM의 각 메모리 위치에 있는 데이터 라인의 트렌지스터를 on/off = (close/open) = (1/0) 한다. 이렇게 메인메모리에 bit의 형태로 정보가 저장된다.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/hcw01_04.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;위 그림의 예시를 보면 횡(horizontal)으로 지나가는 두 번째 address line이 활성화 되어 transistors 가 활성화(close) 된 것을 볼 수 있다. 종(vertical)으로 지나가는 두 번째와 여덟 번 째 data line에는 전류가 흐르는 상태(1)이기 때문에, 그 자리에 위치한 capacitor에 정보(1 or 0)가 저장된다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게-정보가-flash-memory에-저장되는가&quot;&gt;&lt;strong&gt;어떻게 정보가 Flash Memory에 저장되는가?&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Flash Memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플래시 메모리는 메모리 칩 안에 정보를 유지시키는 데에 전력이 필요 없는 비휘발성 메모리이다. 게다가 플래시 메모리는 읽기 속도가 빠르며(단, 개인용 컴퓨터에서 메인메모리로 쓰이는 DRAM만큼 빠르지는 않고, 순차읽기속도는 하드디스크가 더 빠를 수 있음) 하드 디스크 보다 충격에 강하다. 이러한 특징으로 배터리로 동작하는 장치에서 저장 장치로 많이 사용한다. 플래시 메모리의 또 다른 장점은 강한 압력이나 끓는 물에도 견딜 만큼, 물리적인 힘으로 거의 파괴되지 않는다는 점이다.&lt;br /&gt;[위키피디아, “플레시 메모리”, &lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_memory&quot;&gt;https://en.wikipedia.org/wiki/Flash_memory&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&quot;flash-memory-in-detailsoptional&quot;&gt;Flash Memory in Details(optional)&lt;/h3&gt;
&lt;h6 id=&quot;하드웨어-및-반도체-개념-optional&quot;&gt;하드웨어 및 반도체 개념 (optional)&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Flash memory is laid out along a grid of printed circuits running at right angles to each other. In one direction, the circuit traces are &lt;strong&gt;word addresses&lt;/strong&gt;; circuits at a right angle to them represent the &lt;strong&gt;bit addresses&lt;/strong&gt;. The two addresses combine to create a unique number address called a cell.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image The &lt;strong&gt;cell&lt;/strong&gt; contains two transistors that together determine if an intersection represents a 0 or a 1. One transistor—the &lt;strong&gt;control gate&lt;/strong&gt;—is linked to one of the passing circuits called the &lt;strong&gt;word line&lt;/strong&gt;, which determines the word address.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image A thin layer of metal oxide separates the control gate from a second transistor, called the &lt;strong&gt;floating gate&lt;/strong&gt;. When an electrical charge runs from the &lt;strong&gt;source&lt;/strong&gt; to the &lt;strong&gt;drain&lt;/strong&gt;, the charge extends through the floating gate, on through the &lt;strong&gt;metal oxide&lt;/strong&gt;, and through the control gate to the word line.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image A &lt;strong&gt;bit sensor&lt;/strong&gt; on the word line compares the strength of the charge in the control gate to the strength of the charge on the floating gate. If the control voltage is at least half of the floating gate charge, the gate is said to be &lt;strong&gt;open&lt;/strong&gt;, and the cell represents a 1. Flash memory is sold with all cells open. Recording to it consists of changing the appropriate cells to zeros.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image Flash memory uses &lt;strong&gt;Fowler-Nordheim tunneling&lt;/strong&gt; to change the value of the cell to a zero. In tunneling, a current from the bit line travels through the floating gate transistor, exiting through the source to a &lt;strong&gt;ground&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image Energy from the current causes electrons to boil off the floating gate and through the metal oxide, where the electrons lose too much energy to make it back through the oxide. They are trapped in the control gate, even when the current is turned off.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image The electrons have become a wall that repels any charge coming from the floating gate. The bit sensor detects the difference in charges on the two transistors, and because the charge on the control gate is below 50 percent of the floating gate charge, it is considered to stand for a zero.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image When it comes time to reuse the flash memory, a current is sent through &lt;strong&gt;in-circuit wiring&lt;/strong&gt; to apply a strong electrical field to the entire chip, or to predetermined sections of the chip called &lt;strong&gt;blocks&lt;/strong&gt;. The field energizes the electrons so they are once again evenly dispersed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;메모리-구조&quot;&gt;메모리 구조&lt;/h2&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">CIT) how computers work 강의자료</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22hcw01_00.png%22%7D" /></entry><entry><title type="html">Linux System Programming [2]: File Input/Output</title><link href="http://localhost:4000/book/linux_system_programming_2/" rel="alternate" type="text/html" title="Linux System Programming [2]: File Input/Output" /><published>2017-07-29T22:44:20+09:00</published><updated>2017-07-29T22:44:20+09:00</updated><id>http://localhost:4000/book/linux_system_programming_2</id><content type="html" xml:base="http://localhost:4000/book/linux_system_programming_2/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/lsp.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#파일-입출력&quot; id=&quot;markdown-toc-파일-입출력&quot;&gt;파일 입출력&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;h2 id=&quot;파일-입출력&quot;&gt;파일 입출력&lt;/h2&gt;
&lt;p&gt;파일은 읽거나 쓰기전에 반드시 열려있어야 한다. 커널은 파일 테이블이라고 하는, 프로세스별로 열린 파일 목록을 관리한다. 이 테이블은 음이 아닌 정수 값인, 파일 디스크립터(fd)로 인덱싱 되어 있다. 이 테이블의 각 항목은 열린 파일에 대한 정보(inode, 메타데이터)를 갖고있다.
프로세스는 3가지 파일 디스크립터(fd)를 기본적으로 가지고 있다. 이는 0(stdin), 1(stdout), 3(stderr) 이다.
즉, 파일 디스크립터는 단순히 일반 파일만을 나타내는 것이 아니라, 장치파일, 파이프, 디렉토리, 뮤텍스, FIFO, 소켓 접근에도 사용되며 “모든 것이 파일이다.”라는 유니그 철학에 따라 읽고 쓸 수 있는 모든 것은 파일디스크립터로서 접근할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;파일-열기&quot;&gt;파일 열기&lt;/h3&gt;
&lt;p&gt;파일에 접근하는 가장 기본적인 방법은 read() 시스템 콜과 write()시스템 콜 이다. 물론 이에 앞서 open()이나 create()시스템콜을 사용하여 파일을 열어줘야 하고, 접근이 끝난 뒤에는 close()로 파일을 닫아주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;open() 시스템 콜&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;open() 시스템 콜은 경로 이름이 name인 파일을 파일 디스크립터에 mapping 하고, 성공하면 이 파일 디스크립터를 반환한다. 파일 오프셋은 파일의 시작시점인 0으로 설정되며, 파일은 flags로 지정한 플래그에 대응하는 접근 모드로 열리게 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;open()시스템 콜 access flag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;flags parameter는 O_RDONLY, O_WRONLY, O_RDWR 중 하나를 포함해야 한다. 다음과 같은 코드는 읽기 전용 모드(O_RDONLY)로 파일을 열도록 요청한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;home/rocky/Document/foo.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_RDONLY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
  ERROR
  */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다음과 같이 flags parameter에 비트 OR 연산을 통해 새로운 flag를 추가해서 열기 동작을 변경할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;home/rocky/Document/foo.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_WRONLY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_TRUNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
  ERROR
  */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;위 코드에서는 foo.txt파일을 쓰기모드로 연다. 파일이 이미 존재하면 길이를 0으로 잘라버린다. O_CREATE flag를 명시하지 않았기 때문에 파일이 존재하지 않으면 호출은 실패한다.&lt;/p&gt;

&lt;p&gt;상세한 flag들과 description은 다음 링크를 참고하자.&lt;br /&gt;
&lt;a href=&quot;http://man7.org/linux/man-pages/man2/open.2.html&quot;&gt;http://man7.org/linux/man-pages/man2/open.2.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;파일-생성&quot;&gt;파일 생성&lt;/h3&gt;
&lt;p&gt;새로운 파일의 소유자는 그 파일을 생성한 프로세스의 uid를 따른다. 또한 새로운 파일의 그룹 역시 그 파일을 생성한 그룹의 gid를 따른다. 일부 리눅스 시스템에서는 다르게 동작하기도 하지만 흔치 않다.&lt;/p&gt;

&lt;p&gt;새로운 파일이 생성되면 만들어진 파일의 접근 권한은 mode parameter에 따라 설정된다. mode parameter는 시스템 관리자에게는 낮익은 유닉스 접근권한 비트 집합이며 8진수 이다. 예를들어 접근권한 “0664”는 소유자는 읽기 쓰기가 가능하고, 나머지 모든 사용자는 읽기만 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;home/rocky/Document/foo.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_WRONLY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_CREATE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_TRUNC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0664&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
  ERROR
  */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;위의 예제 코드는 쓰기 모드로 foo.txt파일을 연다. 파일이 존재하지 않는다면 접근권한이 0644인 파일을 생선한다. 그리고 파일이 존재하면 길이를 0으로 잘라버린다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;creat()함수&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;O_WRONLY&lt;/td&gt;
      &lt;td&gt;O_CREATE&lt;/td&gt;
      &lt;td&gt;O_TRUNC 조합을 통해 파일을 생성하는 것은 너무나도 일반적인 경우여서 이러한 방식을 지원하는 시스템 콜로서 다음과 같은 함수가 존재한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;** create가 아니라 creat이다, 유닉스 설계자의 인간적인 실수로 아직도 남아있다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;home/rocky/Document/foo.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;0664&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myFd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/*
  ERROR
  */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;위와 같은 코드로 foo.txt라는 파일을 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;open()시스템 콜과 creat()시스템 콜은 성공하면 파일 디스크립터를 반환하고 실패할 경우 -1을 반환한다. 또한 적절한 값으로 errno 변수를 설정 해 준다.&lt;/p&gt;

&lt;p&gt;This is a work in progress.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">리눅스 시스템 프로그래밍 [2]: 파일 입출력</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22lsp2.png%22%7D" /></entry><entry><title type="html">Linux System Programming [1-2]: Error handling</title><link href="http://localhost:4000/book/linux_system_programming_1_2/" rel="alternate" type="text/html" title="Linux System Programming [1-2]: Error handling" /><published>2017-07-23T22:44:20+09:00</published><updated>2017-07-23T22:44:20+09:00</updated><id>http://localhost:4000/book/linux_system_programming_1_2</id><content type="html" xml:base="http://localhost:4000/book/linux_system_programming_1_2/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/lsp.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;p&gt;시스템 프로그래밍에서 에러는 함수 리턴값으로 확인이 가능하며 특수한 변수인 errno로 에러가 발생한 구체적인 이유를 알 수 있다. glibc에서는 라이브러리와 시스템 콜 양쪽을 지원하도록 errno 값을 제공한다. 정확한 값은 함수에 따라 다르겠지만 보통 에러가 발생하면 -1을 반환한다. 이 에러값은 호출한 측에 에러가 발생했음을 알려주지만, 자세한 에러 이유는 알려주지 않는다. 이때 에러의 원인을 찾아내기 위해 errno 변수를 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;errno 변수는 &lt;errno.h&gt; 헤더에 다음과 같이 정의되어 있다.&lt;/errno.h&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이 값은 errno에 값을 대입한 함수를 호출한 직후에만 유효하다. 연이어 다른 함수를 실행하면 이 값이 바뀌므로 주의해야 한다.&lt;/p&gt;

&lt;p&gt;errno 변수는 직접 읽고 쓸 수 있으며, 변경 가능한 변수(Variable)이다. errno 값은 그 에러에 대한 설명이 다음과 같이  mapping되어 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;선행처리기 문자열 정의&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EPERM&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Operation not permitted */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ENOENT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* No such file or directory */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ESRCH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* No such process */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EINTR&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Interrupted system call */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EIO&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* I/O error */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ENXIO&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* No such device or address */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;E2BIG&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Arg list too long */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ENOEXEC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Exec format error */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EBADF&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Bad file number */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ECHILD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* No child processes */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EAGAIN&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Try again */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ENOMEM&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Out of memory */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EACCES&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Permission denied */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EFAULT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Bad address */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ENOTBLK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Block device required */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EBUSY&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Device or resource busy */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EEXIST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* File exists */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EXDEV&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;/* Cross-device link */&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;C 라이브러리에는 errno 값을 그에 맞는 문자열 표현으로 변환하는 함수를 몇 가지 제공하고 있다. 이런 함수는 사용자에게 에러를 알려줄 때 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;perror() 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;이 함수는 str이 가르키는 문자열 뒤에 콜론(:)을 붙인 다음에 errno가 기술하는 현재 에러를 문자열로 바꿔 표준 에러(stderr: standard error)로 내보낸다. 활용도를 높이려면 다음과 같이 함수 이름을 문자열에 포함 해 주면 좋다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;close&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;strerror()와 strerror_r()함수&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;string.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strerror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;string.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strerroe_r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;strerror()함수는 errno 에러에 대한 설명이 담긴 문자열 포인터를 반환한다. 비슷하게 strerror_r()함수는 buf가 가르키는 지점부터 len만큼 버퍼를 체운다.&lt;/p&gt;

&lt;p&gt;흔히 하는 실수로, 라이브러리나 시스템 콜에서 errno 값을 바꿀 수 있다는 사실을 잊은 채 errno 값을 검사하는 경우가 있다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fsync failed!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;I/O error on %d!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;위 코드에는 다음과 같이 수정되어야 한다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fsync failed: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stderror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// I/O와 관련된 에러라면 exit
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;I/O error on %d!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;싱글스레드 프로그램에서 errno는 전역변수 이지만, 멀티스레드 프로그램에서 errno는 스레드 별로 저장되므로 스레드에서 역시 사용가능하다.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">리눅스 시스템 프로그래밍 [1-2]: 에러처리 - errno 변수를 활용한 에러 확인 및 처리</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22lsp1_1.png%22%7D" /></entry><entry><title type="html">Github page 제작 후기 with Jekyll</title><link href="http://localhost:4000/whatever/githubpages_review/" rel="alternate" type="text/html" title="Github page 제작 후기 with Jekyll" /><published>2017-07-22T22:44:20+09:00</published><updated>2017-07-22T22:44:20+09:00</updated><id>http://localhost:4000/whatever/githubpages_review</id><content type="html" xml:base="http://localhost:4000/whatever/githubpages_review/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;h3 id=&quot;wix-platform&quot;&gt;WIX platform&lt;/h3&gt;
&lt;p&gt;가입형 블로그에서 설치형 블로그로 이전을 하겠다고 마음먹은지 몇 개월만에 드디어 어느정도 완성이 된 것 같다.
호주에서 인턴을 하면서 공부하고 연구했던 것들은 정리하기위해 처음 WIX라는 매우 간단하고 직관적인 가입형 블로그 플랫폼으로 블로그를 시작했다. 우선 간단하게 WIX 플랫폼에 대해서 평가하자면, 비전공자들도 매우 쉽게 웹페이지를 만들수 있게 시스템이 잘 갖추어져 있었다. 당시 웹프론트에 대한 도메인지식이 정말 하나도 없었고 블로그를 잘 관리해야겠다기 보단 연구한 것을 남기기 위해서 블로그를 시작했기 때문에, 꽤 만족스럽게 이용했던 것 같다. 일단 드래그 &amp;amp; 드랍으로 웹페이지를 만들 수 있어서 편했고, 소셜링크라던가 Tagging, 구글 검색 연동 등 직접 하기 귀찮은 것들도 쉽게 가져다 쓸 수 있었다.&lt;/p&gt;
&lt;h3 id=&quot;왜-설치형-블로그여야-하는가&quot;&gt;왜 설치형 블로그여야 하는가&lt;/h3&gt;
&lt;p&gt;이렇게 쉽고 편한 가입형 블로그에서 설치형 블로그로 넘어가게 된 첫번째 계기는, 역시나 유료서비스 문제 때문이다. WIX는 무료 블로그 플랫폼을 표방하지만, 사실은 하단 및 상단에 뜨는 WIX광고를 없애려면 돈을 내야한다. 또한 블로그 도메인역시 wix의 이름과 함께한다. 또한 어느정도 블로그 관리를 하다보니, 가입형 블로그의 어쩔 수 없는 단점들이 느껴졌다. 일단 블로그 인터페이스가 제한적이라는 점, 블로그 포스팅을 로컬에서 관리할 수 없다는점, 각종 웹 플러그인을 전혀 사용할 수 없다는점 등. 그리고 가장 큰 단점으로는 내 웹페이지가 아니라는 생각이 들어서 그닥 정이가지 않는다는점이다. 이러한 생각에 가입형블로그에서 설치형 블로그로 넘어가야겠다는 생각을 했고, github page로 플랫폼을 옮겨왔다.&lt;/p&gt;
&lt;h3 id=&quot;github-pages-장점&quot;&gt;github pages 장점&lt;/h3&gt;
&lt;p&gt;Github page로 플랫폼을 옮기고 포스팅도 하면서 가장 좋았던 점은, 역시 github에서 서비스하는 거라 그런지 블로그 포스팅도 git을 통해 버전관리를 할 수 있다는점이다. 애초에 로컬에서 포스팅을 관리할 수 있었으면 좋겠다는 생각을 했었지만, git으로 버전관리 및 형상관리 까지 할 수있다니 너무 완벽했다. 또다른 장점은 웹프론트를 전혀 모르는 사람도 getting started with를 보면서 쉽게 시작할 수 있다는것이다. 사실 나는 블로그 테마를 선정하는 것 부터 아이콘이나 티저 이미지 같은것을 고르는데 엄청 고민을 많이 했었는데, 이런것에 크게 신경쓰지 않는 사람이라면 정말 빨리 완성된 결과물을 볼 수 있을 것 같다. 마지막으로 요즘 나름 대세? 인것 같은 마크다운을 사용해서 html의 수많은 태그들을 몰라도 깔금하고 완성도 높은 포스팅을 할 수 있다는 것. 사실 워드 프로세서로 문서를 작성하는 것 과 크게 걸리는 시간이 다르지 않을 많금 마크다운은 간결하고 직관적인 문법이라 따로 배울 필요도 없을 것 같다.&lt;/p&gt;

&lt;p&gt;Github page는 jekyll를 통해 생성하였고, 전체 웹페이지의 구성 역시 jekyll에서 제공해주었기 때문에, 집중해야하는 블로그 콘텐츠에 좀 더 집중할 수 있었다. 그리고 가장 강력한 장점 중 한가지는 웹서버를 둘 필요 없이 github에 commit만 해 두면 알아서 호스팅을 해 준다는점이다.&lt;/p&gt;

&lt;p&gt;아직 글꼴이나 플러그인 적용을 다 하지는 못했지만, 나머지는 콘텐츠가 좀 더 풍부해진 뒤에 더하도록 해야겠다.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">가입형 블로그에서 설치형 블로그로.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22jekyll.png%22,%20%22teaser%22=%3E%22octojekyll.png%22%7D" /></entry><entry><title type="html">Linux System Programming [1]: Introduction to Core Concepts</title><link href="http://localhost:4000/book/linux_system_programming_1/" rel="alternate" type="text/html" title="Linux System Programming [1]: Introduction to Core Concepts" /><published>2017-07-22T22:44:20+09:00</published><updated>2017-07-22T22:44:20+09:00</updated><id>http://localhost:4000/book/linux_system_programming_1</id><content type="html" xml:base="http://localhost:4000/book/linux_system_programming_1/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/lsp.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#시스템-프로그래밍&quot; id=&quot;markdown-toc-시스템-프로그래밍&quot;&gt;시스템 프로그래밍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#api-와-abi&quot; id=&quot;markdown-toc-api-와-abi&quot;&gt;API 와 ABI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#리눅스-프로그래밍의-개념&quot; id=&quot;markdown-toc-리눅스-프로그래밍의-개념&quot;&gt;리눅스 프로그래밍의 개념&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;/nav&gt;

&lt;h2 id=&quot;시스템-프로그래밍&quot;&gt;시스템 프로그래밍&lt;/h2&gt;
&lt;p&gt;시스템 프로그래밍의 세가지 가장 중요한 키워드는 시스템 콜, C라이브러리, C컴파일러 이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템 콜 - 운영체제에 리솟스나 서비스를 요청하려고 사용자 영역(텍스트 편집기나 게임)에서 시작해서 커널 내부로 들어가는 함수 호출. 64비트 리눅스 운영체제 기준 약 300여개의 시스템콜이 있다. 보안과 안정성의 이유로 사용자 프로그램은 커널 코드를 직접 실행하거나 커널 내부 데이터를 실행할 수 없다.&lt;/li&gt;
  &lt;li&gt;C 라이브러리 - 유닉스 어플리케이션의 핵심, 최신 리눅스 시스템에서는 GNU C Library인 glibc가 제공된다.&lt;/li&gt;
  &lt;li&gt;C 컴파일러 - gcc라는 리눅스 c 컴팡일러가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;api-와-abi&quot;&gt;API 와 ABI&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;API - 소프트웨어의 소스코드 레벨에서 서로 인터페이스를 하는 방식을 정의, API의 표준 인터페이스는 함수이며 상위 레벨의 소프트웨어에서 하위 레벨의 소프트웨어의 함수를 호출할 수 있다.&lt;/li&gt;
  &lt;li&gt;ABI - API가 소스 코드 수준의 인터페이스를 정의한다면 ABI는 특정 아키텍쳐 간에서 동작하는 소프트웨어 간의 바이너리 인터페이스를 정의한다. ABI는 바이너리의 호환성을 보장하며 이는 오브젝트 코드를 다시 컴파일하는 수고 없이 같은 ABI를 진원하는 시스템이라면 동일한 기능을 수행하도록 보장한다. 예를 들어, ABI는 함수가 실행되는 방식, 인자가 전달되는 방식, 레지스터에 값을 저장하는 방식 등(calling convention)를 정의한다. 따라서 컴파일러나 툴체인에 의해서 강제되므로 일반적인 프로그래머는 알고 있을 필요가 없지만, 이를 개발 할 필요가 있는 시스템 프로그래머는 ABI를 알아야 함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;리눅스-프로그래밍의-개념&quot;&gt;리눅스 프로그래밍의 개념&lt;/h2&gt;
&lt;p&gt;리눅스를 포함한 유닉스 시스템은 상호간의 추상화와 인터페이스를 제공한다. 파일과 프로세스, 파이프와 소켓을 다루기 위한 인터페이스 등 이러한 것들이 유닉스의 핵심이다.&lt;/p&gt;

&lt;h6 id=&quot;파일과-파일시스템&quot;&gt;파일과 파일시스템&lt;/h6&gt;
&lt;p&gt;파일에 접근하기 위해서는 파일의 정보를 갖고 있는 메타이데이와 연결된 파일 디스크립터를 통해 참조할 수 있다. 리눅스 커널 내에서 파일 디스크립터(fd)는 정수형으로 표현되며, 응용프로그램이 파일에 접근할 때 직접 사용한다. 리눅스 시스템 프로그래밍의 상당부분은 바로 이 파일 디스크립터를 열고 조작하고 닫는 작업이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 - 연속적으로 나열된 바이트 배열에 저장된 데이터&lt;/li&gt;
  &lt;li&gt;오프셋(offset) - 파일내부의 특정 위치, 열려있는 파일의 오프셋은 커널이 유지하는 메타데이터의 핵심, 오프셋의 최대 크기는 시스템에서 저장할 수 있는 한 파일의 최대 크기와 같으며 최신 리눅스 시스템에서는 64비트 값이다.&lt;/li&gt;
  &lt;li&gt;아이노드(inode) - 사용자는 파일의 이름을 통해 파일에 접근하지만 실제로 파일은 inode number라고 하는 파일시스템 내에서 고유한 정수 값으로 참조된다. inode 는 inode number를 포함하여 소유자, 접근날자, 파일 크기 등의 메타데이터를 저장한다.&lt;/li&gt;
  &lt;li&gt;디렉토리 - 파일의 이름과 mapping되는 inode number를 저장하는 파일의 한 종류, 따라서 디렉토리도 자체의 inode가 있고 이를 통해 계층적 구조를 나타낼 수 있음. (ex, /home/rocky/Document/happy.txt)&lt;/li&gt;
  &lt;li&gt;절대경로/상대경로 - root에서부터의 경로/working directory에서부터의 경로&lt;/li&gt;
  &lt;li&gt;하드링크 - 동일한 inode에 여러 이름을 mapping하는 것. 파일의 삭제 시 모든 하드링크가 삭제될 때 까지 파일을 삭제하지 못하도록 보장하기 위해 각 inode는 파일시스템 내부에 링크 카운터를 두어 이를 추적한다. 링크 카운터가 0이 되면 실제로 삭제&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;심볼릭 링크 - 링크로 연결된 파일의 완전한 경로 이름을 포함하는 독자적인 inode와 데이터를 갖는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;파일시스템 - 파일시스템은 파일과 디렉토리를 정형적이고 유효한 계층 구조 안에 모아놓은 것. 파일시스템을 파일과 디렉토리라는 전역 네임스페이스 안에 개별적으로 추가하거나 제거할 수 있다. 이러한 과정을 mount/unmount라고 한다. 네임스페이스에저 정해진 장소를 마운트 포인트라고 하며, 개별 파일시스템은 여기에 마운트 된다. 마운트 된 파일시스템의 루트 디렉토리는 마운트 포인트에서 접근 가능하다. 예를 들어, 이동식 USB 메모리를 /media/extusb 에 마운트하면 USB메모리에 있는 파일시스템 루트는 마운트 포인트인 /media/extusb 에서 접근 가능하다. 리눅스 시스템에서는 루트 파일시스템 이 “/”에 존재하며 그 외 다른 파일시스템을 다른 마운트 포린트에 마운트 하는 과정은 필요에 따라 선택한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;프로세스&quot;&gt;프로세스&lt;/h6&gt;
&lt;p&gt;리눅스에서의 프로세스는 작은 범위에서는 실행중인 오브젝트 코드, 넓게는 단순한 오브젝트 코드를 넘어 데이터, 리소스, 상태, 가상화 된 컴퓨터를 포함한다.&lt;/p&gt;

&lt;p&gt;프로세스는 가상화를 위한 추상 개념이다. 선점형 멀티태스킹과 가상 메모리를 지원하는 리눅스 커널은 가상화 된 프로세서와 가상화 된 메모리를 프로세스에 제공한다. 커널은 동작중인 프로세스가 시스템 프로세서를 공유하도록 빈틈없고 투명하게 프로세스를 선점하고 스케쥴링한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스레드 - 각 프로세스는 스레드를 하나 이상 포함한다. 스레드는 프로세스 내부에서 실행하는 활동의 단위이며, 코드를 실행하고 프로세스 동작 상태를 유지하는 추상 개념이다. 스레드에 대한 자세한 내용은 7장에서 다루도록 한다.&lt;/li&gt;
  &lt;li&gt;프로세스의 계층 구조 - 각각의 프로세스는 PID(프로세스 ID)라고 하는 고유한 양수 값으로 구분된다. 리눅스에서 프로세스는 프로세서 트리라는 엄격한 계층 구조를 형성한다. 보통 init program 이라는 첫 번째 프로세스가 루트가 되고 fork() 시스템콜을 통해 프로세스를 복제 하여 자식프로세스로 만드는 과정을 통해 계층 트리를 형성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;사용자user와-그룹group&quot;&gt;사용자(User)와 그룹(Group)&lt;/h6&gt;
&lt;p&gt;리눅스에서 권한은 사용자(User)와 그룹(Group)의 형태로 제공된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자(User) - uid(user id)는 고유한 양수의 값을 가지면 사용자를 구분한다. 따라서 프로세스마다 프로세스의 사용자가 누구인지 파악하기 위해 uid가 존재한다. 실제 사용자 이름(문자) 와 uid는 역시 파일의 형태로 /etc/passwd 파일에 저장되어 있다. uid 0은 “root”라는 특수한 사용자를 가르킨다. root 사용자는 특별한 권한이 있으며, 시스템에서 거의 모든 작업을 실행할 수 있다.&lt;/li&gt;
  &lt;li&gt;그룹(Group) - 특정 파일이나 디렉토리를 특정 권한이 있는 사용자”들” 만 사용하기 위해 해당 사용자들에게 권한을 부여하여 그룹 단위로 묶어 관리할 수 있다. 모든 사용자는 하나 이상의 그룹에 속해있다. 주 그룹이나 로그인 그룹은 etc/passwd에 지정하며 추가 그룹은 ect/group 에 지정한다. 따라서 프로세스마다 대응하는 gid가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;권한&quot;&gt;권한&lt;/h6&gt;
&lt;p&gt;파일마다 소유자, 소유자 그룹, 그리고 세 가지 접근 권한 비트가 있다. 이 비트는 소유자, 소유자 그룹, 그 외 모든 사용자가 파일을 읽고, 쓰고, 실행하는 능력을 기술한다. 세 가지 각각의 그룹마다 세 비트가 할당되어 총 9bit로 권한에 대한 정보를 표현하며, 이 역시 파일의 inode에 저장된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;권한 비트와 값&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;비트&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;8진수&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;텍스트&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;접근 권한&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;400&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;r - - - - - - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;소유자 읽기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- w - - - - - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;소유자 쓰기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - x - - - - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;소유자 실행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;040&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - r - - - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그룹 읽기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;020&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - - w - - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그룹 쓰기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;010&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - - - x - - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그룹 실행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;004&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - - - - r - -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그 외 사용자 읽기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;002&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - - - - - w -&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그 외 사용자 쓰기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;001&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;- - - - - - - - x&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그 외 사용자 실행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h6 id=&quot;시그널signal&quot;&gt;시그널(Signal)&lt;/h6&gt;
&lt;p&gt;시그널은 비동기식(Asynchronous) 단방향 알림 메커니즘이다. 커널에서 프로세스로, 프로세스에서 다른 프로세스로, 아니면 프로세스 자기 자신에게 시그널을 보낼 수 있다. 일반적으로 시그널은 segmentation fault나 사용자가 ctrl-c 를 누르는 경우와 같이 특정 이벤트가 발생했음을 알려준다. 리눅스 커널에는 약 30여개의 시그널이 존재한다.&lt;/p&gt;

&lt;h6 id=&quot;프로세스간-통신inter-process-communication-ipc&quot;&gt;프로세스간 통신(Inter Process Communication; IPC)&lt;/h6&gt;
&lt;p&gt;리눅스에서 지원하는 IPC메커니즘은 파이프, 네임드파이프, 세마포어, 메세지큐, 공유메모리, 뮤텍스 등이 있다.&lt;/p&gt;

&lt;h6 id=&quot;에러처리&quot;&gt;에러처리&lt;/h6&gt;
&lt;p&gt;개인적으로 좀 더 자세히 다루고 싶고 중요한 내용이기에 새로운 포스팅으로 다루겠다.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">리눅스 시스템 프로그래밍 [1]: 핵심 개념 소개; 리눅스 시스템프로그래밍을 위한 핵심 개념 및 도메인 지식에 관하여</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22lsp1.png%22%7D" /></entry><entry><title type="html">Linux System Programming [0]: Prologue</title><link href="http://localhost:4000/book/linux_system_programming_0/" rel="alternate" type="text/html" title="Linux System Programming [0]: Prologue" /><published>2017-07-22T22:44:20+09:00</published><updated>2017-07-22T22:44:20+09:00</updated><id>http://localhost:4000/book/linux_system_programming_0</id><content type="html" xml:base="http://localhost:4000/book/linux_system_programming_0/">&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/lsp.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;h3 id=&quot;공부하기에-앞서&quot;&gt;공부하기에 앞서&lt;/h3&gt;
&lt;p&gt;리눅스 시스템 프로그래밍을 기초부터 탄탄하게 공부 할 목적으로 구매한 책이다. 일단 O’REILLY에서 나온 책이기에 밑음이 갔고, 다루고 있는 내용을 나름 시간을 두고 훑어 보았을 때, 파일 시스템이나 입출력, 메모리쪽에 무게를 두고 설명 해 주는 것 같아 마음에 들었다.&lt;/p&gt;

&lt;p&gt;블로그 Book Review를 통해 한 단원(장)을 독파 할 때 마다 공부했던 내용을 정리 해 볼 예정이다. 책에서 나온 예제 코드 또한 typing 해서 함께 포스팅 할 계획이다. 책 한 단원에서 다룬 모든 내용을 블로스 포스팅 한 개 페이지에서 다루기는 어렵기 때문에, 키워드 위주로 포스팅 할 예정이며, 예제 코드는 가능한 한 전부 다룰 예정이다.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">리눅스 시스템 프로그래밍 [0]: 프롤로그</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22lsp0.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (5)</title><link href="http://localhost:4000/research/csiro06/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (5)" /><published>2017-02-15T19:01:50+09:00</published><updated>2017-02-15T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro06</id><content type="html" xml:base="http://localhost:4000/research/csiro06/">&lt;h3 id=&quot;image-reconstruction&quot;&gt;Image Reconstruction&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;a href=&quot;https://www.youtube.com/watch?v=A1ZUN6HhKXg&quot;&gt;
		&lt;img src=&quot;http://localhost:4000/images/csiro_6_0.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 700px;&quot; /&gt;
	&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;I followed the big concept of reconstruction from the precedent research “Radio tomographic imaging with wireless networks.” They suggest a mathematical model using RSSI to obtain images of moving objects [1]. The following is the mathematical linear model that represents relationship of image vector and RSSI vector.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_6_2.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_6_3.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;y is the vector of all difference RSS measurements, W is the weighting matrix, and x is the attenuation image to be estimated, all measured in decibels (dB). W is of dimension M × N , with each column representing a single voxel, and each row describing the weighting of each voxel for that link. σ_N^(-2) is node variance and C_x is priori covariance matrix.&lt;/p&gt;

&lt;p&gt;Detailed mathematical description of each factor in the equation is skipped in this document because it is described in detail in the pater. On the other hand, In this document, I’ll go into more detail about the vector y because it can be vary depend on the environment and even at the pater, it looks like open issue.&lt;/p&gt;

&lt;p&gt;y is the vector of all the differences between RSS measurements in the network, but also it can be the vector of standard deviations at a certain timestamp. I tried to reconstruct image using 3 difference vector y and all of them brought meaningful result.&lt;/p&gt;

&lt;p&gt;First. I set up vector y as a difference of RSSI in T_n with T_(n-1) which is one cycle. In that way. It shows most accurate reconstruction image. However, moving object (or person) stop moving during the measurement, the object disappear on the reconstruction image because the network adapt to new stable environment.&lt;/p&gt;

&lt;p&gt;Second, I set up vector as difference of RSSI in T_n with T_0. RSSI of T_0 means RSSI of start point that there’s no moving object or any person. So the system can detect object which is not moving much more effectively than fist method. However, considering that the RSSI can be affected easily from small changes of environment, this second method can be adapted during short time otherwise it will bring inaccurate image.&lt;/p&gt;

&lt;p&gt;Third, as I mentioned above, I used standard deviations as y. It showed similar images of First approach and It showed more accurate images when the iteration number increased.&lt;/p&gt;

&lt;p&gt;Consequently, I implemented device application and reconstruction algorithm with first approach which shows the best result but I think the other two approaches also would be good alternative plan depend on the environment or with additional algorithm&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;em&gt;__&lt;/em&gt;&lt;br /&gt;
[1] Wilson, Joey, and Neal Patwari. “Radio tomographic imaging with wireless networks.” IEEE Transactions on Mobile Computing 9.5 (2010): 621-632.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">Image Reconstruction</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_6_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (5)</title><link href="http://localhost:4000/research/csiro05/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (5)" /><published>2017-02-15T19:01:50+09:00</published><updated>2017-02-15T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro05</id><content type="html" xml:base="http://localhost:4000/research/csiro05/">&lt;h3 id=&quot;test-configuration&quot;&gt;Test Configuration&lt;/h3&gt;

&lt;h5 id=&quot;nodes-deployment&quot;&gt;nodes deployment&lt;/h5&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_5_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 500px;&quot; /&gt;
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;node must be deployed from the top left to the bottom right like the picture.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;node configuration&lt;/p&gt;

    &lt;p&gt;NUM_OF_NODE = 20&lt;br /&gt;
  NUM_OF_LINK = 20*19 = 381&lt;br /&gt;
  NUM_OF_ONESIDE = 6&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reconstruction Image Configuration&lt;/p&gt;

    &lt;p&gt;RAW = 25&lt;br /&gt;
  NUM_OF_VOXEL = 25*25 = 625&lt;br /&gt;
  NORMALIZED_PIXEL_WITH = 0.984&lt;br /&gt;
  WIDTH_OF_WEIGHTING_ELLIPSE = 0.02&lt;br /&gt;
  PIXEL_CORRELATION_CONSTANT = 3&lt;br /&gt;
  PIXEL_VARIANCE = 0.4&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">Test Configuration</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_5_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (4)</title><link href="http://localhost:4000/research/csiro04/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (4)" /><published>2017-02-14T19:01:50+09:00</published><updated>2017-02-14T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro04</id><content type="html" xml:base="http://localhost:4000/research/csiro04/">&lt;h3 id=&quot;how-to-design-device-application-for-rti&quot;&gt;How to design Device Application for RTI&lt;/h3&gt;

&lt;p&gt;There are two device application. One is for nodes consist of radio tomography network and the other is a master node which schedules other nodes and collects raw data from them. To be specific, master node sends command packet to other nodes so that the other nodes broadcast packet. In this way master node can control or schedule the other nodes by adjusting signal interval time or iteration number.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In radio tomography system, radio interference brings about severe problem in the system because Received Signal Strength Index(RSSI) is the most important information to detect object. If more than two nodes broadcast at the same time, the RSSI of the network would be messed up at that time . To avoid this problem,  I made time slot and every pre-defined time slot, only one node can broadcast so that there is no signal interference.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The following is example of radio tomography network of N =5, iteration =3. (N = number of node)&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_4_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;As the above graph, master node sends command packet to each node. The command packet is also broadcasted but for the visibility of graph, I drew a single dotted black arrow on the graph. In each scheduling time slot, a node broadcast packet 3 times (red dotted arrow, iteration =3). The packet carries the RSSI information of previous cycle from each other nodes so that the master node receives those packet and send it to test pc by serial communication.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;N 3 -46 -45 -43 0 -43
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above string is packet data that node 3 broadcast. “N” mean normal and “3” mean node ID and each numbers in minus sign are the average RSSI from each other node. There is “0” RSSI that indicate “from node 3 to node3”&lt;/p&gt;

&lt;p&gt;The followings are github link of source code for device application (contiki application code)&lt;br /&gt;&lt;br /&gt;
Normal node: &lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/radio_tomography&quot;&gt;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/radio_tomography&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
Master node: &lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/rti_mater&quot;&gt;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/rti_mater&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">How to design Device Application for RTI</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_4_1.png%22%7D" /></entry></feed>
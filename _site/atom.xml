<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.4">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-22T16:32:23+09:00</updated><id>http://localhost:4000/</id><title type="html">Rocky’s Research Blog</title><subtitle>This is a Research Blog of Rocky Lim</subtitle><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (5)</title><link href="http://localhost:4000/research/csiro06/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (5)" /><published>2017-02-15T19:01:50+09:00</published><updated>2017-02-15T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro06</id><content type="html" xml:base="http://localhost:4000/research/csiro06/">&lt;h3 id=&quot;image-reconstruction&quot;&gt;Image Reconstruction&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;a href=&quot;https://www.youtube.com/watch?v=A1ZUN6HhKXg&quot;&gt;
		&lt;img src=&quot;http://localhost:4000/images/csiro_6_0.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 700px;&quot; /&gt;
	&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;I followed the big concept of reconstruction from the precedent research “Radio tomographic imaging with wireless networks.” They suggest a mathematical model using RSSI to obtain images of moving objects [1]. The following is the mathematical linear model that represents relationship of image vector and RSSI vector.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_6_2.gif&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_6_3.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;y is the vector of all difference RSS measurements, W is the weighting matrix, and x is the attenuation image to be estimated, all measured in decibels (dB). W is of dimension M × N , with each column representing a single voxel, and each row describing the weighting of each voxel for that link. σ_N^(-2) is node variance and C_x is priori covariance matrix.&lt;/p&gt;

&lt;p&gt;Detailed mathematical description of each factor in the equation is skipped in this document because it is described in detail in the pater. On the other hand, In this document, I’ll go into more detail about the vector y because it can be vary depend on the environment and even at the pater, it looks like open issue.&lt;/p&gt;

&lt;p&gt;y is the vector of all the differences between RSS measurements in the network, but also it can be the vector of standard deviations at a certain timestamp. I tried to reconstruct image using 3 difference vector y and all of them brought meaningful result.&lt;/p&gt;

&lt;p&gt;First. I set up vector y as a difference of RSSI in T_n with T_(n-1) which is one cycle. In that way. It shows most accurate reconstruction image. However, moving object (or person) stop moving during the measurement, the object disappear on the reconstruction image because the network adapt to new stable environment.&lt;/p&gt;

&lt;p&gt;Second, I set up vector as difference of RSSI in T_n with T_0. RSSI of T_0 means RSSI of start point that there’s no moving object or any person. So the system can detect object which is not moving much more effectively than fist method. However, considering that the RSSI can be affected easily from small changes of environment, this second method can be adapted during short time otherwise it will bring inaccurate image.&lt;/p&gt;

&lt;p&gt;Third, as I mentioned above, I used standard deviations as y. It showed similar images of First approach and It showed more accurate images when the iteration number increased.&lt;/p&gt;

&lt;p&gt;Consequently, I implemented device application and reconstruction algorithm with first approach which shows the best result but I think the other two approaches also would be good alternative plan depend on the environment or with additional algorithm&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;em&gt;__&lt;/em&gt;&lt;br /&gt;
[1] Wilson, Joey, and Neal Patwari. “Radio tomographic imaging with wireless networks.” IEEE Transactions on Mobile Computing 9.5 (2010): 621-632.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">Image Reconstruction</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_6_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (5)</title><link href="http://localhost:4000/research/csiro05/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (5)" /><published>2017-02-15T19:01:50+09:00</published><updated>2017-02-15T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro05</id><content type="html" xml:base="http://localhost:4000/research/csiro05/">&lt;h3 id=&quot;test-configuration&quot;&gt;Test Configuration&lt;/h3&gt;

&lt;h5 id=&quot;nodes-deployment&quot;&gt;nodes deployment&lt;/h5&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_5_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 500px;&quot; /&gt;
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;node must be deployed from the top left to the bottom right like the picture.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;node configuration&lt;/p&gt;

    &lt;p&gt;NUM_OF_NODE = 20&lt;br /&gt;
  NUM_OF_LINK = 20*19 = 381&lt;br /&gt;
  NUM_OF_ONESIDE = 6&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reconstruction Image Configuration&lt;/p&gt;

    &lt;p&gt;RAW = 25&lt;br /&gt;
  NUM_OF_VOXEL = 25*25 = 625&lt;br /&gt;
  NORMALIZED_PIXEL_WITH = 0.984&lt;br /&gt;
  WIDTH_OF_WEIGHTING_ELLIPSE = 0.02&lt;br /&gt;
  PIXEL_CORRELATION_CONSTANT = 3&lt;br /&gt;
  PIXEL_VARIANCE = 0.4&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">Test Configuration</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_5_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (4)</title><link href="http://localhost:4000/research/csiro04/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (4)" /><published>2017-02-14T19:01:50+09:00</published><updated>2017-02-14T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro04</id><content type="html" xml:base="http://localhost:4000/research/csiro04/">&lt;h3 id=&quot;how-to-design-device-application-for-rti&quot;&gt;How to design Device Application for RTI&lt;/h3&gt;

&lt;p&gt;There are two device application. One is for nodes consist of radio tomography network and the other is a master node which schedules other nodes and collects raw data from them. To be specific, master node sends command packet to other nodes so that the other nodes broadcast packet. In this way master node can control or schedule the other nodes by adjusting signal interval time or iteration number.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In radio tomography system, radio interference brings about severe problem in the system because Received Signal Strength Index(RSSI) is the most important information to detect object. If more than two nodes broadcast at the same time, the RSSI of the network would be messed up at that time . To avoid this problem,  I made time slot and every pre-defined time slot, only one node can broadcast so that there is no signal interference.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;The following is example of radio tomography network of N =5, iteration =3. (N = number of node)&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_4_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;As the above graph, master node sends command packet to each node. The command packet is also broadcasted but for the visibility of graph, I drew a single dotted black arrow on the graph. In each scheduling time slot, a node broadcast packet 3 times (red dotted arrow, iteration =3). The packet carries the RSSI information of previous cycle from each other nodes so that the master node receives those packet and send it to test pc by serial communication.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;N 3 -46 -45 -43 0 -43
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above string is packet data that node 3 broadcast. “N” mean normal and “3” mean node ID and each numbers in minus sign are the average RSSI from each other node. There is “0” RSSI that indicate “from node 3 to node3”&lt;/p&gt;

&lt;p&gt;The followings are github link of source code for device application (contiki application code)&lt;br /&gt;&lt;br /&gt;
Normal node: &lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/radio_tomography&quot;&gt;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/radio_tomography&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
Master node: &lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/rti_mater&quot;&gt;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples/rti_mater&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">How to design Device Application for RTI</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_4_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (3)</title><link href="http://localhost:4000/research/csiro03/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (3)" /><published>2017-02-10T19:01:50+09:00</published><updated>2017-02-10T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro03</id><content type="html" xml:base="http://localhost:4000/research/csiro03/">&lt;h3 id=&quot;how-to-get-started-contiki-with-a-cc2650-board-in-linux&quot;&gt;How to get started Contiki with a CC2650 board in Linux&lt;/h3&gt;

&lt;p&gt;this description assumes you’ll follow all steps by &lt;strong&gt;“root”&lt;/strong&gt; and you are using &lt;strong&gt;ubunutu 14.04&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At first, download or clone the example source codes and tools from the github project(https://github.com/csiro-wsn/contiki-examples) or my github repository (&lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples&quot;&gt;https://github.com/RockyLim92/radioTomography/tree/master/contiki-examples&lt;/a&gt;&lt;/strong&gt;). I recommend to use mine because there are a few syntax errors in “tools/tools_intall.sh” in csiro github.&lt;/p&gt;

&lt;p&gt;First of all, install git and i386 libraries. The followings are the install script.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install libc6:i386 libx11-6:i386 libasound2:i386 libatk1.0-0:i386 libcairo2:i386 libcups2:i386 libdbus-glib-1-2:i386 libgconf-2-4:i386 libgdk-pixbuf2.0-0:i386 libgtk-3-0:i386 libice6:i386 libncurses5:i386 libsm6:i386 liborbit2:i386 libudev1:i386 libusb-0.1-4:i386 libstdc++6:i386 libxt6:i386 libxtst6:i386 libgnomeui-0:i386 libusb-1.0-0-dev:i386 libcanberra-gtk-module:i386 gtk2-engines-murrine:i386 unzip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Second, install tool chain by running “tools/tools_intall.sh” shell script file. After then, you can compile some example codes or your own contiki code for CC2650. The following is compile command.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make TARGET=srf06-cc26xx BOARD=sensortag/cc2650
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To grogram your .elf file to CC2650 board, use Uniflash(&lt;strong&gt;&lt;a href=&quot;http://www.ti.com/tool/uniflash&quot;&gt;http://www.ti.com/tool/uniflash&lt;/a&gt;&lt;/strong&gt;). If you get the error message about “libgcrypt.so.11” during the installation, install libgcrypt11_1.5.3.-5 library&lt;/p&gt;

&lt;p&gt;After install Uniflash, update Uniflash by “Help”
Go to “/opt/ti/uniflash_3.4/ccs_base/common/uscif/xds110/” and connect your device into your Linux.
Type&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./xdsdfu –m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and wait a little and type again&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./xdsdfu –f firmware.bin –r
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is kind of initializing command at the first time&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">How to get started Contiki with a CC2650 board in Linux</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3E%22ubuntu14_04_02.jpg%22,%20%22teaser%22=%3E%22ubuntu14_04.jpg%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (2)</title><link href="http://localhost:4000/research/csiro02/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (2)" /><published>2017-02-10T19:01:50+09:00</published><updated>2017-02-10T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro02</id><content type="html" xml:base="http://localhost:4000/research/csiro02/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;p&gt;In this project, I used TI CC2650 Sensortag to develop radio tomography in low-power sensor network device. I developed Contiki application and programmed it to the CC2650. By using CC2650 and Contiki, this radio tomography system could achieve low-power consumption.&lt;/p&gt;

&lt;h3 id=&quot;ti-sensortag-cc2650&quot;&gt;TI Sensortag CC2650&lt;/h3&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_2_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The CC2650 device is a wireless MCU targeting Bluetooth Smart, ZigBee and 6LoWPAN, and ZigBee RF4CE remote control applications. The device is a member of the CC26xx family of cost-effective, ultra-low power, 2.4-GHz RF devices. The ability to consume very low active RF and MCU currents and low-power mode currents provides excellent battery life for the device. This ability also lets the device operate on small coin cell batteries and in energy-harvesting applications. [1]&lt;/p&gt;

&lt;h3 id=&quot;contiki&quot;&gt;Contiki&lt;/h3&gt;

&lt;p&gt;Contiki is an open source operating system for the Internet of Things. Contiki connects tiny low-cost, low-power microcontrollers to the Internet. Contiki is a powerful toolbox for building complex wireless systems. [2]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;__&lt;br /&gt;&lt;br /&gt;
[1] Multi-Standard CC2650 SensorTag Design Guide, &lt;strong&gt;&lt;a href=&quot;http://www.ti.com/lit/ug/tidu862/tidu862.pdf&quot;&gt;http://www.ti.com/lit/ug/tidu862/tidu862.pdf&lt;/a&gt;&lt;/strong&gt; &lt;br /&gt;
[2] Contiki, &lt;strong&gt;&lt;a href=&quot;http://www.contiki-os.org&quot;&gt;http://www.contiki-os.org&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">TI Sensortag CC2650 and Contiki</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_2_1.png%22%7D" /></entry><entry><title type="html">CSIRO) Radio Tomography System using low-power Sensor Network Device (1)</title><link href="http://localhost:4000/research/csiro01/" rel="alternate" type="text/html" title="CSIRO) Radio Tomography System using low-power Sensor Network Device (1)" /><published>2017-02-10T19:01:50+09:00</published><updated>2017-02-10T19:01:50+09:00</updated><id>http://localhost:4000/research/csiro01</id><content type="html" xml:base="http://localhost:4000/research/csiro01/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;h3 id=&quot;what-is-radio-tomographic-imaging&quot;&gt;What is radio tomographic imaging?&lt;/h3&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_1_1.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 420px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Radio Tomographic Imaging (RTI) is an emerging technology for imaging passive objects (objects that do not carry a transmitting device) with wireless networks [1]. The key source of image is Received Signal Strength Index(RRSI) which has a nature that it decreases(usually) when objects disturb the going ahead radio signal.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/csiro_1_2.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 450px;&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The picture above shows the RRSI values as time goes by, and there are some changes up and down at certain times because of a moving object. In fact, the graph was obtained from short experiments when the experimenter move around the nodes. In the radio tomography network, all of the nodes makes a lots of RSSI data extremely fast and by using the data, images are created.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Working as a intern in CSIRO, I was on project regarding radio tomography. The purpose of this project is developing radio tomography system by using low power sensor network device. For this, I used TI Sensortasg cc2650 as a low power device. and I used Contiki-OS for device application OS for radio tomography system.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;There are two major steps for Developing Radio Tomography using low power network device. First one is to develop the device application that I use, TI Sensortag. Next one is to reconstruct image form data that collected by using network devices.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;I implemented Contiki device application for nodes that consist the Radio Tomography Network. I also implemented Contiki device application of master node that schedules the other nodes and collects data from the network. Next, I deployed the nodes around target area so the radio signal can pass through the area. I collected raw data of RSSI of each node in the radio tomography network and reconstructed image of the area.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Node scheduling concepts of the device application and reconstruction algorithm will be covered in the next chapters. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;_&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[1] Wilson, Joey, and Neal Patwari. “Radio tomographic imaging with wireless networks.” IEEE Transactions on Mobile Computing 9.5 (2010): 621-632.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html">What is radio tomographic imaging?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22csiro_1_1.png%22%7D" /></entry><entry><title type="html">Publication) Performance Modeling and Measurement of Selective Page-Mapping Table on the OpenSSD Platform</title><link href="http://localhost:4000/research/KIISE/" rel="alternate" type="text/html" title="Publication) Performance Modeling and Measurement of Selective Page-Mapping Table on the OpenSSD Platform" /><published>2016-12-21T19:01:50+09:00</published><updated>2016-12-21T19:01:50+09:00</updated><id>http://localhost:4000/research/KIISE</id><content type="html" xml:base="http://localhost:4000/research/KIISE/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/KIISE.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 700px;&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;abstractionko-kr&quot;&gt;Abstraction(KO-KR)&lt;/h3&gt;

&lt;p&gt;SSD에서 Flash Translation Layer (FTL)은 논리적인 주소를 물리적으로 주소로 바꾸어 주는 역할을 수행한다. FTL은 SSD의 성능에 크게 영향을 미친다. 선택적 캐싱 기반 페이지 매핑 FTL은 자주 접근되는 페이지 매핑 엔트리만 메모리에 유지하며 페이지 매핑 테이블을 구현하는 방식이며 Garbage Collection 오버헤드를 최소화하여 SSD 성능을 높인다. 하지만, 워크로드의 특성상 Locality가 낮은 경우 캐시 미스가 발생하여 성능이 낮아지는 문제점을 가진다. 본 논문에서는 이러한 선택적 캐싱 기반 페이지 매핑 FTL의 캐시 된 매핑 테이블 크기에 따라 성능 분석을 수행한다. 특히 성능 예측 모델 개발을 위해 OpenSSD 플랫폼 상에서 선택적 캐싱 기반 페이지 매핑 FTL을 실제 구현하였으며 파일 시스템 성능 분석 도구를 이용하여 FTL 성능 예측 모델의 정확성을 검증하였다.&lt;/p&gt;

&lt;h3 id=&quot;abstractionen&quot;&gt;Abstraction(EN)&lt;/h3&gt;

&lt;p&gt;Flash Translation Layer(FTL) play a role that translate logical address to physical address in SSD. FTL have an important effect upon the performance of SSD. Demand-based Selective Caching of Page-level Address Mappings FTL(DFTL) is approach that store only continual page mapping entry. In this approach it increases the performance of the SSD by minimizing Garbage Collection overhead. However, Due to the nature of the workload, cache miss occurs when the locality is low, which results in a lower performance. In this pater, In this paper, performance analysis is performed according to the cached mapping table size of the selective caching-based page mapping FTL. In particular, to develop a performance prediction model, we implemented the selective caching - based page mapping FTL on the OpenSSD platform and verified the accuracy of the FTL performance prediction model using the file system performance analysis tool.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.eiric.or.kr/community/post2.php?m=view&amp;amp;gubun=201612&amp;amp;num=7239&amp;amp;pg=5&amp;amp;seGubun=&amp;amp;seGubun1=&amp;amp;SnxGubun=%C6%F7%BD%BA%C5%CD&amp;amp;searchBy=&amp;amp;searchWord=​&quot; title=&quot;KISSE download&quot;&gt;Download Link&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22KIISE.png%22%7D" /></entry><entry><title type="html">OpenSSD) Jasmine Technical Resources Document 번역</title><link href="http://localhost:4000/research/jasmine/" rel="alternate" type="text/html" title="OpenSSD) Jasmine Technical Resources Document 번역" /><published>2016-12-19T19:01:50+09:00</published><updated>2016-12-19T19:01:50+09:00</updated><id>http://localhost:4000/research/jasmine</id><content type="html" xml:base="http://localhost:4000/research/jasmine/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/jasmine.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 800px;&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;what-i-did&quot;&gt;What I did&lt;/h3&gt;
&lt;p&gt;SSD의 FTL(Flash Translation Layer)개발 도구인 OpenSSD Jasmine 보드의 레퍼런스 메뉴얼 및 개발 가이드를 번역했습니다. 기존의 레퍼런스 메뉴얼과 개발 가이드는 국문으로 된 문서만 제공했는데, OpenSSD를 활용한 프로젝트를 진행하면서 영문으로 된 레퍼런스 메뉴얼과 개발가이드를 만들었으며  OpenSSD 프로젝트 공식 위키에 역자로서 이름을 올리게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;what-is-openssd-project&quot;&gt;What is OpenSSD Project&lt;/h3&gt;
&lt;p&gt;The OpenSSD Project is an initiative to promote research and education on the recent SSD (Solid State Drive) technology by providing easy access to OpenSSD platforms on which open source SSD firmware can be developed. Currently, we have offered an OpenSSD platform based on the commercially successful BarefootTM controller from Indilinx Co., Ltd. In addition, we now support an FPGA-based OpenSSD platform whose hardware and software designs are modifiable. This site is also intended to be a forum to share various simulators, tools, and workload generators and traces related to SSDs, among researchers in academia and industry.&lt;/p&gt;

&lt;h3 id=&quot;some-links&quot;&gt;some Links&lt;/h3&gt;
&lt;p&gt;OpenSSD project :
&lt;strong&gt;&lt;a href=&quot;http://www.openssd-project.org/wiki/The_OpenSSD_Project&quot;&gt;http://www.openssd-project.org/wiki/The_OpenSSD_Project&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Jasmine OpenSSD Platform: Technical Reference Manual (v1.4, in English) (By Preethika Kasu, Donghyun Kang, Heerak Lim) :
&lt;strong&gt;&lt;a href=&quot;http://www.openssd-project.org/mediawiki/images/Jasmine_Tech_Ref_Manual_v.1.4e.pdf&quot;&gt;http://www.openssd-project.org/mediawiki/images/Jasmine_Tech_Ref_Manual_v.1.4e.pdf&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Jasmine OpenSSD Platform: FTL Developer’s Guide (v1.2, in English) (By Preethika Kasu, Donghyun Kang, Heerak Lim) :
&lt;strong&gt;&lt;a href=&quot;http://www.openssd-project.org/mediawiki/images/Jasmine_FTL_Dev_Guide_v.1.2e.pdf&quot;&gt;http://www.openssd-project.org/mediawiki/images/Jasmine_FTL_Dev_Guide_v.1.2e.pdf&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22jasmine.png%22%7D" /></entry><entry><title type="html">Workload Analysis Logging by using FUSE(Filesystem in Userspace)</title><link href="http://localhost:4000/research/test/" rel="alternate" type="text/html" title="Workload Analysis Logging by using FUSE(Filesystem in Userspace)" /><published>2016-12-16T01:22:48+09:00</published><updated>2016-12-16T01:22:48+09:00</updated><id>http://localhost:4000/research/test</id><content type="html" xml:base="http://localhost:4000/research/test/">&lt;nav class=&quot;toc&quot;&gt;

&lt;/nav&gt;

&lt;h3 id=&quot;wla-file-system&quot;&gt;WLA file system&lt;/h3&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
	&lt;img src=&quot;http://localhost:4000/images/WLAFS.png&quot; alt=&quot;Drawing&quot; style=&quot;width: 380px;&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;개요&quot;&gt;개요&lt;/h3&gt;

&lt;p&gt;파일시스템과 리눅스 커널에서 대해서 공부하면서, 공부한 내용을 활용하여 간단한 프로젝트를 진행했습니다. FUSE 플랫폼을 사용하여 나만의 파일시스템을 구축하였습니다. 새로운 파일시스템이 마운트 된 디렉토리 내에서 발생하는 모든 transaction을 분석하여 간단한 Workload 통계량을 Log로서 남겨주는 기능을 합니다. 따라서 본 파일시스템을 Workload Analysis Filesystem(WLA File System, 또는 WLAFS) 라고 naming 하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/RockyLim92/fuse_wla&quot; title=&quot;WLAFS page&quot;&gt;소스코드 보기&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;GitHub Link: &lt;a href=&quot;https://github.com/RockyLim92/fuse_wla&quot;&gt;https://github.com/RockyLim92/fuse_wla&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;abstraction&quot;&gt;Abstraction&lt;/h3&gt;

&lt;p&gt;One of the most difficult tasks in the performance management of a computer system is the activity of statistically analyzing the amount of work done by the computer system from the user to process the requested work, that is, analyzing the workload of the computer system. Typically, workload analysis is an essential activity to calculate a performance baseline for a computer system. Here, the term baseline refers to a reference value used when comparing an object or phenomenon. In the case of performance management, the baseline is used as a reference value for determining a performance target for a target system. This workload analysis process is very important in terms of extracting performance baselines for performance testing&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In general, it is very difficult to provide a standardized workload analysis procedure and method because the applications used in each computer system and the pattern in which the users use the work are different. A workload can exist for any resource available on a computer system, such as storage, memory, processor, or internet access. In this project, we analyze the pattern of workload for storage related to file input / output and storage, and design a new file system for this.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Developing an in-kernel file system is a very challenging task. This is because you need to understand complex kernel code analysis and data structures, and it is also very difficult to load them into existing kernels. Debugging kernel code also requires repetitive system reboots. Therefore, developing a file system in the user space can greatly improve the problems listed above. The Fuse File System is an open source framework for designing and developing file systems at the User Space Level, and the project is underway at http://fuse.sourceforge.net/. FUSE is built-in since the Linux kernel 2.6.15. In this project, we use FUSE to design and develop Userspace File System for workload pattern analysis.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;FUSE works independently with the system’s In-kernel file system. Therefore, using FUSE can provide a standardized Workload Pattern Analysis framework regardless of the file system used in different computer systems. This project aims to design and develop a file system for workload pattern analysis using FUSE based on the above background. We will also apply the developed file system to the actual system and analyze and verify the workload pattern according to various test scenarios.&lt;/p&gt;</content><author><name>Rocky Lim</name><email>rockylim@snu.ac.kr</email><uri>https://rockylim92.github.io/</uri></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/%7B%22feature%22=%3Enil,%20%22teaser%22=%3E%22WLAFS.png%22%7D" /></entry></feed>